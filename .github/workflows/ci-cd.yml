name: WorkProfile CI/CD

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  IMAGE_NAME: workprofile-app
  REGISTRY_USER: naamafisher
  REGISTRY: ghcr.io

jobs:

  # Stage 1: Validation
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Validate Python dependencies
        run: |
          python3 -c "import flask; print('âœ“ Flask OK')"
          python3 -c "import mysql.connector; print('âœ“ MySQL Connector OK')"

      - name: Validate required files exist
        run: |
          test -f Dockerfile && echo "âœ“ Dockerfile exists"
          test -f requirements.txt && echo "âœ“ requirements.txt exists"
          test -f app.py && echo "âœ“ app.py exists"

  # Stage 2: Build & Test Single Container
  build-test:
    runs-on: ubuntu-latest
    needs: validate
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Docker
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        run: docker build -t ${{ env.IMAGE_NAME }} .

      - name: Run container
        run: docker run -d -p 5000:5000 --name app ${{ env.IMAGE_NAME }}

      - name: Wait for container to be ready
        run: sleep 15

      - name: Test main endpoint
        run: curl -f http://localhost:5000/ && echo "âœ“ Main endpoint works"

      - name: Test health endpoint
        run: curl -f http://localhost:5000/health && echo "âœ“ Health endpoint works"

  # Stage 3: Publish to GHCR
  publish:
    needs: build-test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Docker
        uses: docker/setup-buildx-action@v3

      - name: Extract short SHA
        id: version
        run: echo "sha_tag=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Log in to GitHub Container Registry (GHCR)
        run: echo "${{ secrets.GH_TOKEN11 }}" | docker login ${{ env.REGISTRY }} -u ${{ env.REGISTRY_USER }} --password-stdin

      - name: Build image with tags
        run: |
          docker build -t ${{ env.REGISTRY }}/${{ env.REGISTRY_USER }}/${{ env.IMAGE_NAME }}:latest \
                       -t ${{ env.REGISTRY }}/${{ env.REGISTRY_USER }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.sha_tag }} .

      - name: Push image to GHCR
        run: |
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_USER }}/${{ env.IMAGE_NAME }}:latest
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_USER }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.sha_tag }}

  # Stage 4: Docker Compose Integration Test
  docker-compose-test:
    runs-on: ubuntu-latest
    needs: publish
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install Docker Compose
        run: sudo apt-get update && sudo apt-get install -y docker-compose

      - name: Run docker-compose stack
        run: |
          cd docker-compose
          docker-compose up -d
          sleep 90
          curl -f http://localhost:8080/ && echo "âœ“ Nginx proxy OK"
          curl -f http://localhost:8080/health && echo "âœ“ Health OK"
          curl -s http://localhost:8080/health | grep "Database: Healthy" && echo "âœ“ Database connectivity OK"
          docker-compose down -v

  # Stage 5: Manual Kubernetes Deployment Instructions
  manual-k8s-instructions:
    needs: docker-compose-test
    runs-on: ubuntu-latest
    steps:
      - name: Display manual deployment instructions
        run: |
          echo "ðŸ›  Manual Deployment Instructions:"
          echo "1. Login to Killercoda Kubernetes playground"
          echo "2. Apply your Kubernetes manifests from k8s/*.yaml"
          echo "3. Use kubectl wait, kubectl port-forward, and curl to test"
          echo "4. Verify StatefulSet and PVC with kubectl get pvc"
          echo "5. Use kubectl exec into MySQL pod to check DB and data"

